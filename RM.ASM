	PAGE	45,132

	TITLE Noddy88 debugger

	SUBTTL	Decode the reg/mem and mod fields of address byte

	.SALL

	EXTRN	BYTE_COUNT:BYTE
	EXTRN	CURRENT_CS:WORD
	EXTRN	CURRENT_IP:WORD
	EXTRN	CURRENT_OP:BYTE
	EXTRN	DISPLACEMENT_BYTE:NEAR
	EXTRN	DISPLACEMENT_WORD:NEAR
	EXTRN	MOD_TABLE:WORD
	EXTRN	OUTHEX_AX_BUFF:NEAR
	EXTRN	OUTPUT_BX:NEAR
	EXTRN	OUTPUT_BP:NEAR
	EXTRN	OUTPUT_BUFFER:NEAR
	EXTRN	OUTPUT_DI:NEAR
	EXTRN	OUTPUT_LSQB:NEAR
	EXTRN	OUTPUT_PLUS:NEAR
	EXTRN	OUTPUT_SI:NEAR
	EXTRN	OUTPUT_RSQB:NEAR
	EXTRN	REGISTER_PAIRS:BYTE
	EXTRN	SINGLE_REGISTERS:BYTE

	PAGE

	PUBLIC	DEST$EA_SRC$REG
	PUBLIC	DEST$REG_SRC$EA
	PUBLIC	MOD_RM
	PUBLIC	REGISTER

	PUBLIC	RM000$MOD00
	PUBLIC	RM001$MOD00
	PUBLIC	RM010$MOD00
	PUBLIC	RM011$MOD00
	PUBLIC	RM100$MOD00
	PUBLIC	RM101$MOD00
	PUBLIC	RM110$MOD00
	PUBLIC	RM111$MOD00

	PUBLIC	RM000$MOD01
	PUBLIC	RM001$MOD01
	PUBLIC	RM010$MOD01
	PUBLIC	RM011$MOD01
	PUBLIC	RM100$MOD01
	PUBLIC	RM101$MOD01
	PUBLIC	RM110$MOD01
	PUBLIC	RM111$MOD01

	PUBLIC	RM000$MOD10
	PUBLIC	RM001$MOD10
	PUBLIC	RM010$MOD10
	PUBLIC	RM011$MOD10
	PUBLIC	RM100$MOD10
	PUBLIC	RM101$MOD10
	PUBLIC	RM110$MOD10
	PUBLIC	RM111$MOD10

	PUBLIC	RM$MOD11

	PAGE

CODESEG		SEGMENT		PUBLIC

	ASSUME	CS:CODESEG

DEST$EA_SRC$REG PROC
; ea/reg opcodes
	CALL	MOD_RM				;decode mod etc
	MOV	AL,','
	CALL	OUTPUT_BUFFER
	CALL	REGISTER			;output reg field
	RET
DEST$EA_SRC$REG ENDP
  
DEST$REG_SRC$EA PROC
 ; reg/ea opcodes
 	CALL	REGISTER			;output reg field
 	MOV	AL,','
 	CALL	OUTPUT_BUFFER
 	CALL	MOD_RM				;mod field
 	RET
DEST$REG_SRC$EA ENDP

	PAGE
  
REGISTER	PROC
; outputs a register name indexed by reg field
	MOV	AX,CURRENT_CS			;get address byte
	MOV	ES,AX
	MOV	BX,CURRENT_IP
	MOV	BL,ES:[BX+1]			;from memory
	AND	BL,00111000B			;mask reg field
	SHR	BL,1				;index * 2 for 2 char table
	SHR	BL,1				;move down
	XOR	BH,BH
	TEST	CURRENT_OP,00000001B		;test word bit
	JNZ	REG_10				;its a word
	MOV	AL,SINGLE_REGISTERS[BX]		;get register name
	CALL	OUTPUT_BUFFER
	MOV	AL,SINGLE_REGISTERS[BX+1]	;from byte register table
	CALL	OUTPUT_BUFFER
	JMP	REG_EXIT			;done
REG_10:	MOV	AL,REGISTER_PAIRS[BX]		;else its a word register
	CALL	OUTPUT_BUFFER
	MOV	AL,REGISTER_PAIRS[BX+1]
	CALL	OUTPUT_BUFFER
REG_EXIT:
	RET
REGISTER	ENDP

	PAGE

MOD_RM		PROC
; decodes mem/reg part of opcode for general use
	PUSH	SI				;save working registers
	MOV	AX,CURRENT_CS			;get address byte
	MOV	ES,AX
	MOV	BX,CURRENT_IP
	MOV	AL,ES:[BX+1]			;from memory
	MOV	AH,AL				;save a copy
	AND	AH,11000000B			;mask mod field
	MOV	CL,5				;only 5 for word index
	SHR	AH,CL				;set up as index
	XOR	BH,BH				;clear space
	MOV	BL,AH				;place index
	MOV	BX,MOD_TABLE[BX]		;get table entry
	AND	AL,00000111B			;mask r/m field in copy
	XOR	AH,AH				;clear top half
	MOV	SI,AX				;save offset
	SHL	SI,1				;for word table index*2
	CALL	[BX+SI]				;go to output routine
	POP	SI
 	RET
MOD_RM		ENDP

	PAGE
 
RM000$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_RSQB		;]
	RET
RM000$MOD00	ENDP

RM001$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_RSQB		;]
	RET
RM001$MOD00	ENDP
 
RM010$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_RSQB		;]
	RET
RM010$MOD00	ENDP
 
RM011$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_RSQB		;]
	RET
RM011$MOD00	ENDP
 
RM100$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_RSQB		;]
	RET
RM100$MOD00	ENDP
 
RM101$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_RSQB		;]
	RET
RM101$MOD00	ENDP

RM110$MOD00	PROC
	MOV	AX,CURRENT_CS		;direct addressing mode
	MOV	ES,AX
	XOR	BH,BH			;pick up address
	MOV	BL,BYTE_COUNT
	ADD	BX,CURRENT_IP
	MOV	AX,ES:[BX]
	CALL	OUTHEX_AX_BUFF		;put direct address in buffer
	INC	BYTE_COUNT		;two more bytes on the instruction
	INC	BYTE_COUNT
	RET
RM110$MOD00	ENDP

RM111$MOD00	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_RSQB		;]
	RET
RM111$MOD00	ENDP
 
RM000$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE	; -128..+127
	CALL	OUTPUT_RSQB		;]
	RET
RM000$MOD01	ENDP
 
RM001$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM001$MOD01	ENDP
 
RM010$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM010$MOD01	ENDP
 
RM011$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
 	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM011$MOD01	ENDP
 
RM100$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM100$MOD01	ENDP

RM101$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM101$MOD01	ENDP

RM110$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM110$MOD01	ENDP

RM111$MOD01	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_BYTE
	CALL	OUTPUT_RSQB		;]
	RET
RM111$MOD01	ENDP

RM000$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD	; -32768..+32767
	CALL	OUTPUT_RSQB		;]
	RET
RM000$MOD10	ENDP

RM001$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM001$MOD10	ENDP
 
RM010$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM010$MOD10	ENDP
 
RM011$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS		;+
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM011$MOD10	ENDP
 
RM100$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_SI		;SI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM100$MOD10	ENDP
 
RM101$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_DI		;DI
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM101$MOD10	ENDP

RM110$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BP		;BP
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM110$MOD10	ENDP

RM111$MOD10	PROC
	CALL	OUTPUT_LSQB		;[
	CALL	OUTPUT_BX		;BX
	CALL	OUTPUT_PLUS
	CALL	DISPLACEMENT_WORD
	CALL	OUTPUT_RSQB		;]
	RET
RM111$MOD10	ENDP

RM$MOD11	PROC

COMMENT	%

 This means r/m field to be treated as reg field
 second operand is also register
 the only trick is to check word flag to see if byte or word

%
	MOV	AX,CURRENT_CS				;get address byte
	MOV	ES,AX
	MOV	BX,CURRENT_IP
	MOV	SI,BX
	MOV	AL,ES:[BX+1]				;fetch address byte
	AND	AL,00000111B				;prepare index
	XOR	BH,BH					;clear space
	MOV	BL,AL					;set up index
	SHL	BX,1					;for word table
	CMP	BYTE PTR ES:[SI],8CH			;mov seg reg?
	JZ	RM111					;must be word
	CMP	BYTE PTR ES:[SI],8EH			;the other direction
	JZ	RM111					;must be word
	TEST	CURRENT_OP,00000001B			;byte or word?
	JNZ	RM111					;word
	MOV	AL,SINGLE_REGISTERS[BX]			;get register name
	CALL	OUTPUT_BUFFER
	MOV	AL,SINGLE_REGISTERS[BX+1]
	CALL	OUTPUT_BUFFER
	JMP	RM11_EXIT				;done
RM111:	MOV	AL,REGISTER_PAIRS[BX]
	CALL	OUTPUT_BUFFER
	MOV	AL,REGISTER_PAIRS[BX+1]
	CALL	OUTPUT_BUFFER
RM11_EXIT:
	RET
RM$MOD11	ENDP

CODESEG		ENDS

	END

